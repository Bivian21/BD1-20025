'use strict';self.MicMonitor=function(){function l(b){return void 0===b||""===b?!0:{deviceId:{exact:b}}}function m(b,d){return navigator.mediaDevices.getUserMedia({audio:l(b)}).then(function(c){const e=new AudioContext,n=e.createMediaStreamSource(c),h=e.createAnalyser();n.connect(h);a.interval&&(console.log("Clearing previous micMonitor callback"),clearInterval(a.interval),a.interval=void 0);const k=new Float32Array(h.fftSize);a.interval=setInterval(function(){h.getFloatTimeDomainData(k);var f=0;
for(const g of k)f+=g*g;f=100*Math.sqrt(f/k.length);try{d(f)}catch(g){console.log("Got failure to post message for mic monitor so assuming its time to stop.  e\x3d"+g),n.disconnect(),e.close(),Utils.stopStream(c),clearInterval(a.interval),a.interval=void 0}},100)})}let a={};(function(){Utils.isEmbed()||chrome.runtime.onConnect.addListener(function(b){"micmonitor"===b.name&&b.onMessage.addListener(function(d){d.start&&(console.log("Starting mic monitor."),m(d.micId,function(c){b.postMessage({currentValue:c})}))})})})();
a.start=function(b,d){console.log("Requesting mic first in tooltip to make sure we have permission.");navigator.mediaDevices.getUserMedia({audio:l(b)}).then(function(c){Utils.stopStream(c);Utils.isEmbed()?m(b,d):(console.log("Successfully got mic so we can start in background so starting mic monitor client."),a.receivePort=chrome.runtime.connect({name:"micmonitor"}),a.receivePort.postMessage({start:!0,micId:b}),a.receivePort.onMessage.addListener(function(e){void 0!==e.currentValue&&d(e.currentValue)}))}).catch(c=>
{console.error("Failed to get mic in start before handing to background. (err: "+c+")");d(-1,c)})};a.stop=function(){a.receivePort&&(console.log("Stopping mic monitor client."),a.receivePort.disconnect(),a.receivePort=void 0)};return a}();